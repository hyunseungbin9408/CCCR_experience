# ZFS

## 파일시스템이란?

파일 시스템은 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근 할 수 있도록 보관 또는 조직하는 체계를 가리키는 말이다.

파일 시스템은 통상 하드 디스크나 CD-ROM 같은 실제 자료 보관 장치를 사용하여 파일의 물리적 소재를 관리하는 것을 가리키나
네트워크 프로토콜을 수행하는 클라이언트를 통하여 파일 서버 상의 자료로의 접근을 제공하는 방식과 가상의 형태로서 접근 수단만이 존재하는 방식도 
파일 시스템의 범위를 포함 될 수 있다.

파일 시스템은 일반적으로 크기가 일정한 블록들의 배열에 접근 할 수 있는 자료 보관 장치위에 생성되어 이러한 배열들을 조직함으로 파일이나 디렉터리를
만들며 어느 부분이 파일이고 어느 부분이 공백인지를 구분하기 위하여 각 배열에 표시를 해 둔다. 또한 자료를 클러스터 또는 블록이라고 불리는 일정한 단위에
새겨 넣는데 이것이 바로 파일 하나가 필요로 하는 디스크의 최소 공간이다.

## 파일 시스템의 종류

### 데이터베이스 파일 시스템

데이터베이스 기반의 파일 시스템은 최근에 등장한 새로운 개념의 파일 시스템이다. 파일을 계층구조로 관리하지않고 파일의 형식, 주제, 만든이, 내용과 같은
여러 특성에 따라 시스템에서 자동으로 분류하여 관리하는 것이다. 

### 트랜잭션 기반 파일 시스템

트랜잭션 기반 파일 시스템은 파일에 일어난 이벤트나 트랜잭션을 기록하는 시스템이다. 사용자가 수행하는 작업은 여러 개의 파일의 내용을 바꿀 수 있다.
이 바뀐 내용들은 서로 연관되어 있는 경우가 많으므로 이 내용들이 논리적으로 서로 연결되어 있어야하는 시스템에서는 이 변화들이 동시에 일어난다는 것이
보장되어야 한다. 트랜잭션 기반 시스템은 이렇게 논리적으로 동시에 수행되어야하는 작업들을 하나의 트랜잭션으로 묶어 만약의 사고가 일어났을때 양쪽에
트랜잭션을 다시 수행하여 오류를 막는다. 또한 모든 트랜잭션은 기록으로 남아 어디서 무슨 일이 언제 수행되었는지가 기록된다. 이러한 파일 시스템은
시스템의 오류를 막기 위해 설계되었으며, 느리지만 안전하다고 볼 수 있다.

***

## ZFS 란?

ZFS(ZettaByte File System) 파일시스템은 제프 본윅(Jeff Bonwick)에 의해 구현되고 디자인 되었다. ZFS는 파일시스템을 관리하는 방법을
근본적으로 바꾸어 새로운 파일 시스템을 구현하였으며, ZFS의 이름에서 알 수 있듯이 거의 무한대의 저장소 용량을 가질 수 있고 표준 `POSIX` 파일시스템을 따르고 있고,
기존 파일시스템보다 관리가 간편하다. 기존의 파일 시스템은 볼륨과 파티션, 파티션의 관리. 파일시스템 확장 및 축소등 많은 작업이 필요했지만 ZFS에서는 이런 작업들을 간단히 할 수 있다.
 ZFS는 파일시스템과 볼륨매니저가 분리되어 있지않고 통합되어 있다.
 
ZFS 파일시스템은 현존하는 유일한 128비트 파일시스템으로 ZFS가 채택한 128비트 파일 시스템구조는 기존의 32~64비트 파일시스템의 160억 배에 이르는 방대한 볼륨 크기를
가능하게 하여 최근 리눅스 2.6 커널에서 차용한 SGI의 64비트 파일 시스템인 XFS와 비교하는 것이 의미가 없을 정도로 스토리지 성능을 거의 무한대로 
확장하였다. ZFS는 안정성을 기반으로 기존의 유닉스 파일시스템을 대체하기 위해 탄생한 파일시스템이다.

### 1. 스토리지 풀

기존의 파일시스템은 물리적인 스토리지에 볼륨을 생성하거나 RAID를 구축하기 위해 별도의 볼륨매니저를 사용하는데 기존 파일시스템의 볼륨 구성방식을 이용하여
확장 시에 서비스의 다운타임이 발생 할 수 밖에 없었다. 볼륨의 레이아웃을 변경하기 위해 디스크 추가 등의 작업이 발생되어도 마찬가지로 다운타임이 발생한다.
그러나 ZFS에서는 물리적인 스토리지를 관리하기 위해서 볼륨을 생성하는 대신에 스토리지 풀이라는 개념을 사용한다. 스토리지 풀을 이용하면 용량을 추가한 직후 
바로 반영되어 즉시 사용가능하다. 또한 모든 파일시스템이 스토리지풀로 구성된 스토리지에 담겨질 수 있고, 각각의 파일시스템은 실제로 사용한 만큼만 공간을
차지하기 때문에 스토리지 공간을 효율적으로 사용 할 수 있다.

<img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/ZFS_Storage.png" alt="drawing" width="700"/>

### 2. ZFS 구조

<img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/ZFS_architect.png" alt="drawing" width="700"/>

기본적으로 ZFS는 위의 그림과 같은 내부적인 구조를 가지고 있다. SPA(Storage Pool Allocator)는 스토리지 풀을 뜻하며 공간할당, 복제, 체크섬, 압축, 암호화, 리소스 제어, 장애관리 등을 제공한다.

ZFS는 오브젝트 기반이먀, 모듈형이고, 확장이 가능합니다. 기본적으로 ZFS는 inode기반의 표준 POSIX를 타파 했으나, 사용자들을 위해 ZPL(ZFS POSIX Layer)이 vnode로부터 들어오는 읽기와 쓰기 작업환경을 변화하여 이를 처리하게 된다. 그리고 DMU(DATA Management Unit)에게 요청하여 SPA에 위치와 사이즈를 기록한다.

ZFS는 사용자 데이터, znode, 디렉토리 DMU, SPA 메타데이터와 같은 DMU 오브젝트들을 매번 저장한다.

풀 전체는 큰 트리 구조로 표현 될 수 있는데, 이 노드들이 무수하게 뻗은 형태로 표현되어진다. 이 트리에서 뿌리가 되는 단일 디스크 블록을 uberblock이라고 부른다.

ZFS는 기본적으로 볼륨을 에뮬레이션한다. ZVOL(ZFS Emulated Volume)은 풀의 공간을 RAW 디바이스로 표현 할 수 있도록 하여 SWAP이나 ZFS에서 UFS 파일시스템을 생성하여 사용 할 수 있도록 도와준다. 또한 ZFS는 end-to-end 체크섬을 이용하여 블록마다 체크섬을 기록하지 않고 uberblock 최상위에 일괄적으로 작성하여 데이터 기록 오류에 대해서 빠른 에러 감지와 복구가 가능하다.

### 3. COW 트랜잭션

ZFS는 COW(Copy-On-Write) 트랜잭션 기반으로 동작한다. 기존의 UFS 파일시스템의 경우는 사용 중인 데이터를 수정 할때 블록을 덮어 쓰기를 하는데, 덮어 쓰기를 하는 도중에 전원 오류등으로 예기치 못한 장애가 발생하게 되면 데이터에 오류가 생기고 파일 시스템은 중요한 데이터를 가리키는 포인팅 정보를 읽어버린다. 이런 문제를 해결하기 위해 fsck 명령을 이용하여 더티블록을 찾아 정보를 재 연결시키는데 fsck를 이용해 디스크 전체를 스캐닝 해야하기 떄문에 복구 시간이 많이 걸리는 문제로 인해 서비스의 다운타임이 증가하는 문제가 있다.

이런 문제를 보다 빠르게 해결하기 위해 근래의 파일시스템에는 저널링 또는 로깅 기능을 이용하여 분리된 저널을 사용하여 시스템 장애시 안전하게 저널을 불러와 복구 할 수 있도록 한다. 저널링이 적용된 파일시스템의 한계는 데이터와 저널을 분리하여 기록하기 위해 불필요한 I/O를 유발한다.

그래서 ZFS는 트랜잭션 파일시스템을 사용한다. COW 트랜잭션 방식을 이용하여 사용 중인 데이터를 가진 블록을 덮어쓰지않고 별도의 다른 블록에 먼저 쓰고 쓰기 작업이 완료되면 포인터를 새로 쓰여진 데이터 블록으로 변경한다. 이 작업은 파일시스템의 최상위에 위치한 단일 디스크 블록인 uberblock에서 이루어진다.

이를 통해 ZFS는 정전 등의 예기치 못한 장애가 발생하더라도 데이터의 손상이 없으며, 또한 fsck를 사용할 필요가 없다.

### 4. 체크섬 (Checksum)

ZFS는 갑작스러운 데이터 오류를 회피하기 위해 메모리 기반의 엔드 투 엔드 체크섬을 제공한다. 대부분의 체크섬 파일 시스템은 오직 비트 오류에 대한 보호만을 제공한다. 그 이유는 스스로 일관성을 유지하는 블럭 자체에 체크섬이 저장되어 있기때문이다. 이런경우 유효성을 검사를 하기위한 다른 외부 작업은 수행될 수 없다. 이러한 방식의 체크섬은 아래와 같은 한계를 가진다.

+ 디스크가 잘못된 블럭을 접근 할 때 잘못 지시된 읽기나 쓰기를 합니다.

+ 체크섬은 어레이 내의 데이터를 검증 하므로 어레이와 서버 메모리 사이 혹은 드라이버 내에서의 DMA 패리티의 오류가 생깁니다.

+ 커널 내부의 잘못된 버퍼에 데이터가 엉킴으로써 발생하는 드라이버 오류가 발생한다.

+ 사용 중인 파일시스템을 스와핑(Swapping) 함으로써 발생하는 의도하지 않게 덮어쓰기를 할 수 있다.

ZFS 체크섬은 블록내에 저장되지 않고 블럭을 가리키는 포인터의 옆에 uberblock의 최상위에 저장된다. uberblock만이 스스로 유효성을 검증하는 SHA-256 체크섬을 가지고 있다. 모든 블럭 체크섬은 서버 메모리 하에서 이루어지므로 앞에서 언급된 잘못 지시된 읽기나 쓰기, 혹은 패리티 오류등은 트리에서 잡아낼 수 있다.

### 5. 스크러빙

모든 디스크는 오류가 발생 할 수 있다. EEC메모리 스크러빙과 비슷하게 ZFS에서도 디스크 스크러빙을 지원한다. 스크러빙은 모든 스토리지 풀을 돌명선 모든 스토리지 풀을 돌면서 모든 블록들을 읽고 체크섬을 이용하여 검증한 후 블록의 복구가 필요한 경우 복구를 하게된다.
