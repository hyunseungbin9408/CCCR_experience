# 컨테이너
 ## 컨테이너란?
  + 단일 컨트롤 호스트상에서 여러개의 고립된 리눅스 시스템들을 실행하기 위한 운영 시스템 레벨 가상화 방법
  
  + 애플리케이션을 실제 구동 환경으로부터 추상화할 수 있는 논리 패키징 메커니즘을 제공
  
  + 사설 데이터 센터나 퍼블릭 클라우드, 개발자의 개인 노트북 컴퓨터처럼 어떤 환경으로든 컨테이너 기반 애플리케이션을 쉽게 지속적으로 배포할 수 있음
  
  + 사용하는 회사들이 업무 영역을 깔끔하게 분리하여 관리 할 수 있다
  
  + 가상 머신과 마찬가지로 애플리케이션을 관련 라이브러리 및 종속 항목과 함께 패키지로 묶어 소프트웨어 서비스 구동을 위한 격리 환경을 마련
 
  + 어플리케이션을 실행하기 위해서 만듬
  
  + 하나의 컨테이너는 하나의 어플리케이션만 실행하는 것이 원칙
  
 
 ## 왜 컨테이너를 사용해야 하는가?
  + 운영체제 수준에서 가상화를 실시하여 다수의 컨테이너를 OS 커널에서 직접 구동한다.
  
  + **컨테이너는 훨씬 가볍고 운영체제 커널을 공유하며, 시작이 훨씬 빠르고 운영체제 전체 부팅보다 메모리를 훨씬 적게 차지한다**.
  
  + 컨테이너를 이용하여 개발자들은 분리되고 예측가능한 개발환경을 생성가능
  
  + 컨테이너는 애플리케이션에 필요한 소프트웨어 종속 항목도 포함할 수 있다. 개발자의 관점에서 이 모든 요소는 애플리케이션이 배포되는 최종 위치에 관계없이 항상 일관성이 있다.
  
  + 개발자와 IT 운영팀이 버그를 잡고 환경 차이를 진단하던 시간을 줄이고 사용자에게 신규 기능을 제공하는 데 집중할 수 있음
  
  + 컨테이너는 폭넓은 구동환경(Linux, Windows, Mac, 가상 머신, 베어메탈, 개발자의 컴퓨터, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드)을 가지기 때문에 개발 및 배포가 쉬워진다. 
  
  + vm으로 app을 배포하려면 vm마다 운영체제를 설치해줘야하기때문에 스토리지용량이 많이 소비가 되어서 비효율적이고 시간도 오래걸린다. 하지만 컨테이너는 하나의 어플리케이션만을 담당하기때문에 효율적이다.
  
 ## 컨테이너의 단점
  + 하나의 운영체제에 수평적으로 확장하기 때문에 운영체제가 문제가 발생하면 모든 컨테이너가 영향을 받는다.
 
 <img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/Linux_Container.png" alt="drawing" width="700"/>
 
  + **컨테이너 실행 과정**
 
 
 ## 컨테이너를 설정할때 주의점
  + 컨테이너를 만들때 cpu제한과 메모리제한 무조건적으로 넣어준다.
  + cpu와 메모리에 가중치를 정해서 중요한 컨테이너순서대로 정해준다.
  + 어플리케이션 성격을 잘 이해해야한다.
    + 일시적인어플리케이션  (ls,hello world...)
    + 계속해서 실행되어야하는 어플리케이션 (httpd,mysql...)
  + 컨테이너와 레지스트리는 반드시 연결되어있어야 컨테이너가 이미지파일을 통해서 만들어진다.
 
 ### Cgroup
 
 <img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/Linux_container_Cgourp.png" alt="drawing" width="700"/>

  + 프로세스 또는 스레드를 그룹화 하여 관리하는 기능
  + 컨테이너가 사용하는 리소스의 양을 제한 할 수 있다.
  + 같은 호스트에서 동작하는 서로 다른 컨테이너에 영향을 주지 않도록 막아주는 역할
  + 다음과 같은 리소스들을 제어할 수 있다.
    + 메모리
    + cpu
    + I/O
    + 네트워크
    + Device노드 (/dev/)
  
 ### namespace
  + VM에서는 각 머신별로 독립적인 공간을 제공하고 서로 충돌하지않는 기능을하는 namespaces을 리눅스에서는 커널에 내장함
  + 다수의 오브젝트를 격리 할 수 있다.
  + 동일한 호스트에서는 같은 PID를 가질 수 없지만 다른 namespace에서는 같은 PID를 가질 수 있다.
  + mnt: 호스트 파일시스템에 구애받지 않고 독립적으로 파일시스템을 마운트 가능
  + pid: 독립적인 프로세스 공간을 할당
  + net: namespace간에 network 충돌방지
  + ipc (systemV IPC): 독립적인 hostname할당
  + user: 독립적인 사용자 할당
  
  
 ### Layered FS (계층형 파일시스템)
  + 기본으로 **AUFS (Another union FS)** 사용했었음
  + 겹치는 파일을 계속해서 다운받을 필요없이 필요한 파일을 그때 마다 차이가 있는 파일만 불러오는 계층적 파일시스템
  + 컨테이너는 이러한 파일들을 읽고 쓸수있는 권한을 부여해줌
  + 코드가 안전하지않아서 레드햇에서 거부함으로써 이제는 더이상 포함되지않음 // Debian 에서는 사용함
  + 그래서 예전에는 LVM을 사용함 // Redhat 에서 사용
  + 지금은 Overlay2를 사용함 // 계층형 파일시스템
  
  <img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/Linux_Container_LayererdFS.png" alt="drawing" width="500"/>
  
