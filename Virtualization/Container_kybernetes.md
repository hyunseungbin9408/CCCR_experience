# 컨테이너
 ## 마이크로서비스 및 Devops
 ### 모놀리식 아키텍처
 + 단일 프로세스에서 실행되거나 몇몇 시스템에서 몇개의 프로세스로 실행되는 거대한 모놀리식 애플리케이션
 
 + 모놀리식 아키텍처에서는 애플리케이션을 매번 릴리스 할때마다 개발자가 전체 애플리케이션을 java의 경우 War파일로 패키징 하거나, Ruby on Rails또는 Node.js의 경우 단일 디렉토리 계층으로 묶어서 배포
 
 + **모놀리식 아키텍처의 장점**
 + 간단한 개발
 
 + 간편한 배포
 
 + 단순한 확장성
 
 + **모놀리식 아키텍처의 단점**
 
 + 코드 품질이 낮아짐 : 큰 APP을 처음 접하는 개발자는 APP을 이해하고 수정하는데 어렵고, 개발 및 업데이트속도가 느려질 수 있음
 
 + 애플리케이션의 시작이 오래걸림 : 규모가 큰 APP일 수록 런타임에서 APP시작이 오래 걸린다.
 
 + 애플리케이션의 지속적인 배포가 어려움 : 하나의 컴포넌트를 업데이트하기 위해 전체 APP을 다시 재배포해야하며, 모든 APP을 중단하고 다시 시작해야한다.
 
 + 애플리케이션 확장의 어려움 : 모놀리식 아키텍처에서는 각 컴포넌트별로 독립적으로 확장 할 수 없다. 이는 전체 APP을 확장해야하며, 이에 따라 시스템 및 하드웨어 자원소모가 많이 되고 클라우드의 경우에는 쓸데없는 리소스가 낭비되어 비용이 많이 나올 수 있음
 
 + 컴포넌트별 개발의 어려움: 애플리케이션 크기가 커지면 조직을 특정기능 한정으로 초점을 맞춘 팀으로 나눌 수 있다. 그러나 모놀리식 APP은 팀이 독립적으로 개발 및 업데이트를 못하게 한다.
 
 + 다양한 기술적용의 어려움 : 예를 들어 JAVA로 개발된 모놀리식 APP이 있다면, 일부 개발에 따라 다른 특정 버전을 사용해야 하는 경우나, 새로운 기술을 도입하기 위해 다른 언어로 개발해야하는 APP이 있는 경우 모놀리식 아키텍처로 개발된 아키텍처에서는 불가능하다.
   
 ### 마이크로서비스 아키텍처
 + 모놀리식 차키텍처가 크기가 커짐에 따라 발생한 문제점을 극복하기 위해 마이크로서비스라는 기능적이고 세분화되고 독립적으로 작동하는 방식을 사용
 
 + 마이크로서비스기반의 APP은 API를 통해 서로 다른 서비스와 통신
 
 + 마이크로서비스 사이에는 일반적인 동기방식인 HTTP/RESTful API 또는 비동기 방식인 AMQP프로토콜을 사용하여 통신한다.
 
 + 마이크로서비스는 각 기능을 구현하기 가장 적합한 언어로 개발 할 수 있다.
 
 + **마이크로서비스 아키텍처의 장점**
 
 + 크고 복잡한 애플리케이션을 지속적으로 배포 할 수 있음
 
   + 향상된 유지 보수성 : 각 서비스는 작기 때문에 이해하고 변경하기 쉬움
   
   + 테스트 용이성 : 각 서비스는 독립적으로 테스트 가능
   
   + 배포 효율성 : 각 서비스는 독립적으로 배포가능
   
   + 독립적으로 개발, 테스트, 배포 및 확장
   
 + 개발에 생산성이 높고 배포 속도가 높음
 
 + 향상된 장애 격리: 장애가 발생한 서비스만 영향을 받음
 
 + 다양한 기술 적용가능
 
 + **마이크로서비스 아키텍처의 단점**
 + 분산시스템 설계에 따른 복잡성
   + 서비스 간 통신 메커니즘을 따로 구현
   
   + 서비스 간 상호작용 테스트
   
 + 배포 및 관리 운영상의 복잡성
 
 + 증가된 리소스 소비
 
 ### DevOps
 + 애플리케이션을 개발하고 운영하는 경우, 개발 팀과 운영 팀 사이에서 가장 큰 문제는 개발 팀에서 APP을 개발하는 환경과 운영 팀에서 개발 된 APP을 프로덕션 시스템에 배포해 운영하는 환경과의 차이 때문에 문제가 발생
 
 + 이러한 차이는 개발자가 사용하는 하드웨어, 운영체제, 사용하는 라이브러리 및 버전까지 많은 부분에서 차이가 발생
 
 + 프로덕션 시스템은 보안패치나 최신 상태로 유지함으로 시간에 따른 변화가 발생
 
 + 이러한 차이점 및 변경사항으로 인해 일관된 환경을 제공하는것이 어려 울 수 있다.
 
 + 애플리케이션의 전체 라이프사이클을 함께 관리하는것이 효율적이라는것을 알게됨
 
 + 이런 소프트웨어 개발, 품질, 운영 팀의 소통 협업 및 통합을 강조하는 개발 환경 및 문화를 DevOps라고 한다.
 
 + 이러한 마이크로서비스 및 DevOps를 가능하게 하는 기술이 쿠버네티스
 
 + 쿠버네티스는 컨테이너 기술을 이용하여 표준화 되고 일관성 있는 환경을 제공하고 DevOps 문화를 가능하게함
 
 ## 컨테이너란?
  + 단일 컨트롤 호스트상에서 여러개의 고립된 리눅스 시스템들을 실행하기 위한 운영 시스템 레벨 가상화 방법
  
  + 애플리케이션을 실제 구동 환경으로부터 추상화할 수 있는 논리 패키징 메커니즘을 제공
  
  + 사설 데이터 센터나 퍼블릭 클라우드, 개발자의 개인 노트북 컴퓨터처럼 어떤 환경으로든 컨테이너 기반 애플리케이션을 쉽게 지속적으로 배포할 수 있음
  
  + 사용하는 회사들이 업무 영역을 깔끔하게 분리하여 관리 할 수 있다
  
  + 가상 머신과 마찬가지로 애플리케이션을 관련 라이브러리 및 종속 항목과 함께 패키지로 묶어 소프트웨어 서비스 구동을 위한 격리 환경을 마련
 
  + 어플리케이션을 실행하기 위해서 만듬
  
  + 하나의 컨테이너는 하나의 어플리케이션만 실행하는 것이 원칙
  
 
 ## 왜 컨테이너를 사용해야 하는가?
  + 운영체제 수준에서 가상화를 실시하여 다수의 컨테이너를 OS 커널에서 직접 구동한다.
  
  + **컨테이너는 훨씬 가볍고 운영체제 커널을 공유하며, 시작이 훨씬 빠르고 운영체제 전체 부팅보다 메모리를 훨씬 적게 차지한다**.
  
  + 컨테이너를 이용하여 개발자들은 분리되고 예측가능한 개발환경을 생성가능
  
  + 컨테이너는 애플리케이션에 필요한 소프트웨어 종속 항목도 포함할 수 있다. 개발자의 관점에서 이 모든 요소는 애플리케이션이 배포되는 최종 위치에 관계없이 항상 일관성이 있다.
  
  + 개발자와 IT 운영팀이 버그를 잡고 환경 차이를 진단하던 시간을 줄이고 사용자에게 신규 기능을 제공하는 데 집중할 수 있음
  
  + 컨테이너는 폭넓은 구동환경(Linux, Windows, Mac, 가상 머신, 베어메탈, 개발자의 컴퓨터, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드)을 가지기 때문에 개발 및 배포가 쉬워진다. 
  
  + vm으로 app을 배포하려면 vm마다 운영체제를 설치해줘야하기때문에 스토리지용량이 많이 소비가 되어서 비효율적이고 시간도 오래걸린다. 하지만 컨테이너는 하나의 어플리케이션만을 담당하기때문에 효율적이다.
  
 ## 컨테이너의 단점
  + 하나의 운영체제에 수평적으로 확장하기 때문에 운영체제가 문제가 발생하면 모든 컨테이너가 영향을 받는다.
 
 <img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/Linux_Container.png" alt="drawing" width="700"/>
 
  + **컨테이너 실행 과정**
 
 
 ## 컨테이너를 설정할때 주의점
  + 컨테이너를 만들때 cpu제한과 메모리제한 무조건적으로 넣어준다.
  + cpu와 메모리에 가중치를 정해서 중요한 컨테이너순서대로 정해준다.
  + 어플리케이션 성격을 잘 이해해야한다.
    + 일시적인어플리케이션  (ls,hello world...)
    + 계속해서 실행되어야하는 어플리케이션 (httpd,mysql...)
  + 컨테이너와 레지스트리는 반드시 연결되어있어야 컨테이너가 이미지파일을 통해서 만들어진다.
 
 ### Cgroup
 
 <img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/Linux_container_Cgourp.png" alt="drawing" width="700"/>

  + 프로세스 또는 스레드를 그룹화 하여 관리하는 기능
  + 컨테이너가 사용하는 리소스의 양을 제한 할 수 있다.
  + 같은 호스트에서 동작하는 서로 다른 컨테이너에 영향을 주지 않도록 막아주는 역할
  + 다음과 같은 리소스들을 제어할 수 있다.
    + 메모리
    + cpu
    + I/O
    + 네트워크
    + Device노드 (/dev/)
  
 ### namespace
  + VM에서는 각 머신별로 독립적인 공간을 제공하고 서로 충돌하지않는 기능을하는 namespaces을 리눅스에서는 커널에 내장함
  + 다수의 오브젝트를 격리 할 수 있다.
  + 동일한 호스트에서는 같은 PID를 가질 수 없지만 다른 namespace에서는 같은 PID를 가질 수 있다.
  + mnt: 호스트 파일시스템에 구애받지 않고 독립적으로 파일시스템을 마운트 가능
  + pid: 독립적인 프로세스 공간을 할당
  + net: namespace간에 network 충돌방지
  + ipc (systemV IPC): 독립적인 hostname할당
  + user: 독립적인 사용자 할당
  
  
 ### Layered FS (계층형 파일시스템)
  + 기본으로 **AUFS (Another union FS)** 사용했었음
  + 겹치는 파일을 계속해서 다운받을 필요없이 필요한 파일을 그때 마다 차이가 있는 파일만 불러오는 계층적 파일시스템
  + 컨테이너는 이러한 파일들을 읽고 쓸수있는 권한을 부여해줌
  + 코드가 안전하지않아서 레드햇에서 거부함으로써 이제는 더이상 포함되지않음 // Debian 에서는 사용함
  + 그래서 예전에는 LVM을 사용함 // Redhat 에서 사용
  + 지금은 Overlay2를 사용함 // 계층형 파일시스템
  
  <img src="https://github.com/hyunseungbin9408/CCCR_experience/blob/master/png/Linux_Container_LayererdFS.png" alt="drawing" width="500"/>
  
***

## 쿠버네티스

### 쿠버네티스란?
+ 쿠버네티스란 명칭은 그리스어로 키잡이와 파일럿을 뜻한다.

+ 구글이 2014년도에 쿠버네티스 프로젝트를 오픈소스화했다.

+ 프로덕션 워크로드를 대규모로 운영하는 15년 이상의 경험과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어있다.

+ 클릭 한 번으로 작동하는 클러스터로 빠르게 시작

+ 멀티 영역과 리전 클러스터를 비롯한 고가용성의 제어 영역 활용

+ 자동 복구, 자동 업그레이드, 출시 채널을 통해 운영 오버헤드 제거

+ 컨테이너 이미지의 취약점 스캔, 데이터 암호화등의 기본 보안

+ 인프라, 애플리케이션, Kubernetes 관련 뷰를 이용한 통합 Clout Monitoring

### 왜 쿠버네티스를 사용하는가?
+ 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션간에 운영체제를 공유함

+ Vm과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU, 매모리, 프로세스공간이 있다.

+ 기본 인프라와 종속성을 끊었기 때문에 클라우드나 OS배포본에 모두 이식 할 수 있다.

+ 리소스 격리

+ 고효율 고집적인 자원 사용량

+ 서비스 디스커버리와 로드 밸런싱
  + 쿠버네티스는 DNS 이름을 사용하거나 자체 IP주소를 사용하여 컨테이너를 노출 할 수 있다.
  + 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱 하고 배포하여 배포가 안정적으로 이루어짐

+ 스토리지 오케스트레이션
  + 쿠버네티스

+ 자동화된 빈 패킹

+ 자동화된 복구

+ 시크릿과 구성관리
